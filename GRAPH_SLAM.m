classdef GRAPH_SLAM < handle
    %UNTITLED2 Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        
        x;            % state vector, holds all poses and landmarks
                      % The first half of the statevector will contain the
                      % poses and the second half will contain the
                      % landmarks. Poses have three variables: x,y,theta.
                      % Landmarks have two variables: x,y. New poses and
                      % landmarkes are appened to the end of their
                      % respective lists
                                  
        numLandmarks; % used to index through state vector
        numPoses;     % used to index through state vector
        
        u;           % control vector, used to store all previous control inputs. The 
                     % furthe down the list the more recent the control.
                     % CURRENTLY AN INPUT TO RUNSLAM
      
        mu;          % pose vector generated by the control vector during the
                     % initalization stage. Will also hold the landmarks on
                     % the map after the poses. The poses will be of the
                     % form x,y,z and the landmarks will be x,y,sig

        z; 
       
                     
        c;
        
        
        omega;  % information matrix
        xi;     % information vector
        
        omegaReduced;
        xiReduced;
        
        contSub;
        measSub;
        
        contData;
        measData;
        
        LM
        
        Q=[.1 0 0;
            0 .1 0;
            0 0 .1;];
       
        % GRAPH_SLAM Parameter Values
        C = 0.2;    % Process Noise Constant, used for calcluation of Q.
        Rc = [.01,5];   % Measurement Noise Constants
        
        R=[.1,0,0;0,.1,0;0,0,.1];
        
        oldOdomPose;
        
        time
    end
    
    methods
        % Constructor - initialize 
        function h = GRAPH_SLAM(contTopic,measTopic,landmarkMethod)
            
            h.mu=[0;0;0];
            
            h.LM = Landmark(landmarkMethod);
            
            h.u=[];
            h.z={};
            h.c={};
            %initialize a subscriber node to turtlebot odometry data
            % Example: '/odom' for odometry data
            h.contSub = rossubscriber(contTopic);
            
            %initialize a subscriber node to kinect laser scan data
            % Example: '/scan' for laser scan data
            h.measSub = rossubscriber('/scan');
            
            %Test data
            h.time=0;
        end
        
        %Collect control and measurment data
        function run(h)
            h.measData = receive(h.measSub);
            h.contData = receive(h.contSub);
            
            p = h.contData.Pose.Pose;
            x_o = p.Position.X;
            y_o = p.Position.Y;
            
            quat = p.Orientation;
            angles = quat2eul([quat.W quat.X quat.Y quat.Z]);
            theta = wrapTo360(rad2deg(angles(1)));
            
            % store current position in terms of x, y, theta (degrees) as ROS sees
            odomPose = [x_o,y_o,theta];
            % End calculate odometery
            %----------------------------------------------------------------------

            % Estimate Robot's pose
            %======================================================================
            % Initialize variables if first iteration
            if(isempty(h.oldOdomPose))
                h.oldOdomPose=odomPose;
            end
            % Get control vector (change in linear displacement and rotation)to
            % estimate current pose of the robot
            delta_D = sqrt((odomPose(1) - h.oldOdomPose(1))^2 + (odomPose(2) - h.oldOdomPose(2))^2);
            delta_Theta = rad2deg(angdiff(deg2rad(h.oldOdomPose(3)),deg2rad(odomPose(3))));
            h.u =[h.u;[delta_D; delta_Theta]];
                
            h.oldOdomPose=odomPose;
            
            h.mu=h.mu;odomPose(1);odomPose(2);odomPose(3);
            
            [observed_LL] = h.LM.getLandmark(h.measData,odomPose);
            temp=[];
            temp2=[];
            if(isempty(observed_LL)==0)
                for ii=1:size(observed_LL,1)
                    temp=[temp,observed_LL(ii,1),observed_LL(ii,2)];
                    temp2=[temp2,observed_LL(ii,3)];
                end
                
                h.z(size(h.z,2)+1)={temp};
                h.c(size(h.c,2)+1)={temp2};
            else
                h.z(size(h.z,2)+1)={[]};
                h.c(size(h.c,2)+1)={[]};
            end
            
            h.time=h.time+1;
            if(mod(h.time,10)==0)
                h.getSolution();
            end
        end
        
        
        %Variables used: control vector, measurment cell array,
        %correspondence cell array
        function getSolution(h)

            %determine number of poses and number of measurments and create
            %an information matrix and vector of the appropriate size
           
            h.numPoses=(length(h.u)/2)+1;
            if(any(~cellfun(@isempty,h.c))) %cellfun returns a vector of 1s
                                            %and 0s where a 1 indicates a 
                                            %empty position in the cell
                                            %array h.c
                                            
                h.numLandmarks=max([h.c{:}]);
            else
                h.numLandmarks=0;
            end
            h.omega=zeros(h.numPoses*3+h.numLandmarks*3);
            h.xi=zeros(h.numPoses*3+h.numLandmarks*3,1);
            
            
            h.initalize();

            
            for holder=1:5
                %linearize
                h.linearize();
                
                %reduce
                h.reduce
                
                %solve
                h.solve();
            end
            
        end
        
        
        
        function initalize(h)
            % Use all control vectors to calculate an mean estimate of the
            % pose. c is only used to extract landmarks from ransac
            
            %The inital position is always x=0,y=0,theta=0
            
            %Each control will contain two elements, the change in distance
            %and the change in theta (delta_D, delta_theta). The total
            %number of controls will be equal to the size of the control
            %vector divided by two. 
            for idx = 1: length(h.u)/2
                
                %Index for keeping track of the current pose being
                %calculated
                poseIdx=(3*idx)+1;
                
                %Index for keeping track of the previous pose
                previousPoseIdx=3*(idx-1)+1; 
                
                %Index for keeping track of the index of the control vector
                controlVecIdx=2*(idx-1)+1;
                
                %Calculate pose x,y, and theta based on previous pose and
                %control vector
                h.mu(poseIdx)= h.mu(previousPoseIdx) + h.u(controlVecIdx)*cosd(h.mu(previousPoseIdx+2)+h.u(controlVecIdx+1));
                h.mu(poseIdx+1)= h.mu(previousPoseIdx+1) + h.u(controlVecIdx)*sind(h.mu(previousPoseIdx+2)+h.u(controlVecIdx+1));
                h.mu(poseIdx+2)= h.mu(previousPoseIdx+2)+h.u(controlVecIdx+1);
                
            end
            
            %add intal landmark map positions to mu. 
            
            %ADD CODE TO EXTRACT LIST OF LANDMARKS FROM HERE
            landmarkIdxs=unique(cell2mat(h.c),'first');
            
            for idx=1:length(landmarkIdxs)
               
                %FIX THIS BY FILLING IN CORRECT NAMES
                landmark=h.LM.findLandmark(idx);
                h.mu(h.numPoses*3+(2*(1-idx))+1)=landmark(1);
                h.mu(h.numPoses*3+(2*(1-idx))+2)=landmark(2);
                h.mu(h.numPoses*3+(2*(1-idx))+3)=idx;

            end
            
            
            
        end
        
        
        
        %Function to create the information matrix and information vector.
        
        %The control vector u will be a vector of the form,
        %distance1,theta1,distance2,theta2,...,distancen,thetan.
        
        %The measurment cell array z will be an nxm cell array where n is
        %the number of poses (a measurment is taken during every pose)
        %and m is the number of features observed in a measurment
        %If no feature is observed in a measurment then that cell in the
        %cell array fill be blank
        
        %The mean pose estimation mu will be vector of the form
        %x1,y1,theta1,x2,y2,theta2,...,xn,yn,thetan. Followed by the mean
        %landmark estimation of the form x1,y1,s1,x2,y2,s2,...,xn,yn,sn
        
        %note to self j will be the index of the landmark plus the size of
        %the number of poses. 
        function linearize(h) 
            
            h.omega(1:3,1:3)=[inf,0,0;0,inf,0;0,0,inf];
            
            %Add all poses to the information matrix
            %idx also represents the current time iteration,ie t=1,2,...,N,
            %not including t=0;
            %consider changing name of measurmentIDX
            for measurmentIdx = 1: length(h.u)/2

                %Index for keeping track of the previous pose from mu
                previousPoseIdx=3*(measurmentIdx-1)+1;
                
                %Index for keeping tack of the current control input
                controlVecIdx=2*(measurmentIdx-1)+1;
                
                x_t=[0;0;0];
                x_t(1)= h.mu(previousPoseIdx) + h.u(controlVecIdx)*cosd(h.mu(previousPoseIdx+2)+h.u(controlVecIdx+1));
                x_t(2)= h.mu(previousPoseIdx+1) + h.u(controlVecIdx)*sind(h.mu(previousPoseIdx+2)+h.u(controlVecIdx+1));
                x_t(3)= h.mu(previousPoseIdx+2) + h.u(controlVecIdx+1);
                
                G = eye(3);
                G(1,3) = -1*h.u(controlVecIdx)*sind(h.mu(previousPoseIdx+2));
                G(2,3) = h.u(controlVecIdx)*cosd(h.mu(previousPoseIdx+2));
                
                
                
                currentInfoStart=(3*(measurmentIdx-1))+1;
                
                %add to omega at xt and x_t-1
                a=[-G';eye(3)]*h.R^-1*[G,eye(3)];
                h.omega(currentInfoStart:currentInfoStart+5,currentInfoStart:currentInfoStart+5)...
                    =a+h.omega(currentInfoStart:currentInfoStart+5,currentInfoStart:currentInfoStart+5); 
                
                %add to xi
                b=[-G;eye(3)]*h.R^-1*[x_t-G*h.mu(previousPoseIdx:previousPoseIdx+2)];
                h.xi(currentInfoStart:currentInfoStart+5)=...
                    b+ h.xi(currentInfoStart:currentInfoStart+5); 
                
            end
            
            

            for measurmentIdx=1:length(h.z)
                %Check if this index of the measurment cell array contains
                %any measurments
                if (isempty(h.z{measurmentIdx})==0)
                    %for all measurments at this index of the measurment
                    %cell array
                    for observationIdx=1:size(h.z{measurmentIdx},1)
                        
                        %j is the index in mu which holds the current
                        %estimate of landmark cs' x position, the y
                        %position is j+1
                        j=((h.c{measurmentIdx}(observationIdx)-1)*3) + h.numPoses*3 +1;

                        %poseIdx is used to find the start of each pose
                        %within the mu vector
                        poseIdx=1+((measurmentIdx-1)*3);
                        
                        delta=[h.mu(j)-h.mu(poseIdx);h.mu(j+1)-h.mu(poseIdx+1)];
                        q=delta'*delta;
                        
                        %IMPORTANT: Double check atan2 calculation
                        z_hat=[sqrt(q);atan2d(delta(2),wrapTo360(angdiff(h.mu(poseIdx+2),delta(1))));h.mu(j+2)];
                        
                        H=1/q*[-sqrt(q)*delta(1), -sqrt(q)*delta(2), 0, sqrt(q)*delta(1), sqrt(q)*delta(2), 0;
                                   delta(2),          -delta(1),   -q,     -delta(2),        delta(1),     0;
                                      0,                   0,       0,         0,               0,         q];
                        
                        %solved: was indexing one behind the expected
                        %position
                        currentInfoPos=(3*(measurmentIdx-1))+1+3;
                        currentInfoLM=(3*h.numPoses)+1+((h.c{measurmentIdx}(observationIdx)-1)*3);
                        
                                    
                        a= H'*h.Q^-1*H;
                        %add to omega at xt and mj
                        
                        %add 1:3,1:3
                        h.omega(currentInfoPos:currentInfoPos+2,currentInfoPos:currentInfoPos+2)...
                            =a(1:3,1:3)+h.omega(currentInfoPos:currentInfoPos+2,currentInfoPos:currentInfoPos+2);
                        
                        %add 4:6,4:6
                        h.omega(currentInfoLM:currentInfoLM+2,currentInfoLM:currentInfoLM+2)=...
                            a(4:6,4:6)+h.omega(currentInfoLM:currentInfoLM+2,currentInfoLM:currentInfoLM+2);
                        
                        %add 1:3,4:6
                        h.omega(currentInfoPos:currentInfoPos+2,currentInfoLM:currentInfoLM+2)...
                            =a(1:3,4:6)+h.omega(currentInfoPos:currentInfoPos+2,currentInfoLM:currentInfoLM+2);
                        
                        %add 4:6,1:3
                        h.omega(currentInfoLM:currentInfoLM+2,currentInfoPos:currentInfoPos+2)...
                            =a(4:6,1:3)+h.omega(currentInfoLM:currentInfoLM+2,currentInfoPos:currentInfoPos+2);
                        

                        b=H'*h.Q^-1*[h.z{measurmentIdx}(observationIdx)-z_hat+H*[h.mu(poseIdx);h.mu(poseIdx+1);h.mu(poseIdx+2);h.mu(j);h.mu(j+1);h.mu(j+2)]];
                        %add to xi at xt and mj
                        
                        h.xi(currentInfoPos:currentInfoPos+2)...
                            =b(1:3)+h.xi(currentInfoPos:currentInfoPos+2);
                        
                        h.xi(currentInfoLM:currentInfoLM+2)...
                            =b(4:6)+h.xi(currentInfoLM:currentInfoLM+2);
                    end
                    
                end
                
            end
            
        end
        
        
        function reduce(h)
            h.xiReduced=h.xi;
            h.omegaReduced=h.omega;
            for  j=0:h.numLandmarks-1
                h.xiReduced(1:(h.numPoses*3+3*j))=  h.xiReduced(1:(h.numPoses*3+3*j))-((h.omegaReduced(1:(h.numPoses*3+3*j),(h.numPoses*3+3*j):(h.numPoses*3+3*j)+2))     * (h.omegaReduced(h.numPoses*3+3*j:(h.numPoses*3+3*j)+2,h.numPoses*3+j*3:(h.numPoses*3+3*j)+2))^-1*(h.xiReduced(h.numPoses*3+j*3:(h.numPoses*3+j*3)+2)));
                h.omegaReduced(1:(h.numPoses*3+3*j),1:(h.numPoses*3+3*j))= h.omega((h.numPoses*3+3*j),1:(h.numPoses*3+3*j))-(h.omega(1:(h.numPoses*3+3*j),(h.numPoses*3+3*j):(h.numPoses*3+3*j)+2))* (h.omega(h.numPoses*3+3*j:(h.numPoses*3+3*j)+2,h.numPoses*3+j*3:(h.numPoses*3+3*j)+2))^-1*h.omega(h.numPoses*3+j*3:(h.numPoses*3+j*3)+2,1:h.numPoses*3+j*3);
                
                
            end
            
            temp=h.xiReduced( (1:(h.numPoses*3)));
            h.xiReduced=temp;
            h.omegaReduced= h.omegaReduced((1:(h.numPoses*3)),(1:(h.numPoses*3)));
            
        end
        
        %This function will solve the information matrix/vector for a best
        %estimate of the pose and landmark positions.
        function solve(h)
            
            
            E=h.omegaReduced^-1; 
            %CHANGE xiReduced(1:h.numPoses) back to xiReduced AFTER TESTING
            h.mu(1:h.numPoses*3)=E*h.xiReduced; 
           
            for featureIdx=1:h.numLandmarks
                %(3x3)(3x1+(3xN)(Nx1) = (3x1)
                j=((featureIdx-1)*3) + h.numPoses*3 +1;

                T=find([h.c{:}]==featureIdx);
                
                posMatrix=zeros(3,length(T)*3);
                posVector=zeros(length(T)*3,1);
                
                for idx=1:length(T)
                   i=((idx-1)*3)+1;
                   pos=((T(idx)-1)*3) +1;
                   
                   posMatrix(1:3,i:i+2) = h.omega(j:j+2,pos:pos+2); 
                   posVector(i:i+2)=h.xi(pos:pos+2);
                end
                
                h.mu(j:j+2)=h.omega(j,j)^-1*(h.xi(j:j+2)+posMatrix*posVector); 
            end
            
        end
        
    end
    
end