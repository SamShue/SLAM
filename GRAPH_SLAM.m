classdef GRAPH_SLAM
    %UNTITLED2 Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        
        x;            % state vector, holds all poses and landmarks
                      % The first half of the statevector will contain the
                      % poses and the second half will contain the
                      % landmarks. Poses have three variables: x,y,theta.
                      % Landmarks have two variables: x,y. New poses and
                      % landmarkes are appened to the end of their
                      % respective lists
                                  
        numLandmarks; % used to index through state vector
        numPoses;     % used to index through state vector
        
        
     %  u;           % control vector, used to store all previous control inputs. The 
                     % furthe down the list the more recent the control.
      
        mu;          % pose vector generated by the control vector during the
                     % initalization stage.
        
        omega;  % information matrix
        xi;     % information vector
        Q;      % Process noise covariance matrix
       
        % GRAPH_SLAM Parameter Values
        C = 0.2;    % Process Noise Constant, used for calcluation of Q.
        Rc = [.01,5];   % Measurement Noise Constants
    end
    
    methods
        % Constructor - initialize state variables and covariances
        function h = GRAPH_SLAM()
      
        end
        
       
        function initalize(u)
            % Use all control vectors to calculate an mean estimate of the
            % pose. 
            
            %The inital position is always x=0,y=0,theta=0
            h.mu={0;0;0};
            
            %Each control will contain two elements, the change in distance
            %and the change in theta (delta_D, delta_theta). The total
            %number of controls will be equal to the size of the control
            %vector divided by two. 
            for idx = 1: sizeof(u)/2
                
                %index for keeping track of the current pose being
                %calculated
                poseIdx=(3*idx)+1;
                %index for keeping track of the previous pose
                previousPoseIdx=3*(idx-1); 
                
                
                %Calculate pose x,y, and theta based on previous pose and
                %control vector
                h.mu(poseIdx)= h.mu(previousPoseIdx) + u(idx)*cosd(h.mu(previousPosIdx+2)+u(idx+1));
                h.mu(poseIdx+1)= h.mu(previousPoseIdx+1) + u(idx)*sind(h.mu(previousPosIdx+2)+u(idx+1));
                h.mu(poseIdx+2)= h.mu(previousPoseIdx+2)+u(2);
            end
            
        end
        
        
        function linearitze(u,z,c,mu) 
            numPoses=h.mu/3;
            numLandmarks=.... % fill in later
            h.omega=zeros
            
            
        end
        
    end
    
end

